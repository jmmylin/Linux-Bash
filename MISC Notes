REPL = Read Eval Print Loop.
Terminal works as a REPL
Terminal is a program (For example, iterm2) and the terminal program is running a shell called BASH.
The shell is the thing that is waiting for my commands.

mv -> rename or move. If existing file with the same name it will overwrite the file. No warnings when this happens.

rm -> has no warning and deletes permanently. (-i will ask you if you are sure.)
Create an alias (rm='rm -i')

Ctrl + L => Shortcut Clear

history


grep <search> <filepath>
grep '^<search' <filepath> 	< To use regex in search.
grep -A1 b file.txt		< find b and print 1 line AFTER
grep -B1 b file.txt		< find b and print 1 line BEFORE
grep -C1 b file.txt		< find b and print 1 line ABOVE and BELOW
grep -i	b file.txt		< ignore case. So, b or B will match. This only prints the part that matches.


echo hello > file.txt		< Writes hello in file.txt this would overwrite everything in file.txt with just hello.
echo hello >> file.txt		< Append hello to the end of the file file.txt.

cat file.txt | grep -i jim	< Pipe the output of cat file.txt into grep and search for the letters jim ignoring case.

type -a <command>
	To see what types there are. This is better than "which"
	
help <command> 
	For built-in commands. Help does not use a pager like less or more does.
	
man <command> 
	For external programs. There are different section to man 3 <command>
	
compgen -b 
	Will show all built-in commands.
	
file filename.txt
	Tells you what type of file it is.
	
echo $PATH
	Will show all the paths it will look by default for a script if no path is provided.
	Separated by colons.
	
echo $PATH | tr : '\n'
	tr translates the : to newline.
	
echo $USER is better than whoami
	whoami is an external program.
	
VARIABLES
Variable remain only for the length of the terminal. When the terminal closes the variables are gone.
name=jimmy
echo $name

foo = 'hello       world'
echo $foo
hello world
	Single quotes Will just show one space and not keep all the other ones.

foo = "hello       world"
echo $foo
hello       world
	Double quotes will keep the spaces.

unset foo
	To remove a variable.
	
thing=`uname -a` is the same as thing=$(uname -a)
	backticks are legacy.
	
#!/usr/bin/env bash 
	is better than just #!/bin/bash because some operating systems might be running an old version of bash.
	
batcat script.sh
	bat shows the script and the output
	
batcat script.sh && bash script.sh
	show the output below too.
	
bash -n script.sh
	-n is a syntax checker
	
help '[['
	To see how to use these and all the options.

echo $?
	To see last exit code
	0 = Success 
		Normal completion
	1 = General error 
		Most scripts & many programs
	2 = Wrong usage / syntax error
		Bash builtins, some core utilities
